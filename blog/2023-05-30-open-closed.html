<head><title>Greg Jensen's Blog</title><link href="/styles.css" rel="stylesheet" type="text/css" /></head><body><div class="center"><a href="/">Home</a><a href="/math.html">Math</a><a href="/contact.html">Contact</a><a href="/blog">Blog</a><a href="https://www.github.com/g-jensen">GitHub</a></div><div class="post"><div><h1>Open-Closed Principle</h1><p>2023-05-30</p><!---
Tags:
[:misc]
--><p>The Open-Closed Principle is very important to follow when writing Clean Code. Uncle Bob refers to the Open-Closed Principle as the moral center of software architecture. The "Open-Closed"
part of the name is saying that in software, modules should be <u>open for extension</u> but <u>closed for modification</u>.</p><p>But what do these phrases mean more specifically? "Open for extension" means that code should be organized in such a way
that new features can simply be plugged in. "Closed for modification" means that the implementation of these plug-ins
should not modify existing source-code. Essentially, this means that when adding a new feature, code should be added instead
of changed.</p><p>To adhere to the Open-Closed Principle, one must abstract and invert. Ugly switch statements or if-chains should
be converted to a single polymorphic method call. Dependencies should point to interfaces to allow modules
to be open for extension.</p><p>But know that adhering to the Open-Closed Principle perfectly is impossible. Customers will always find a way to want a feature that requires modification. And you should only try to predict changes that are similar to past changes.</p></div></div></body>