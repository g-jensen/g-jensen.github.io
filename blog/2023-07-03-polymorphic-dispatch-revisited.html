<head><title>Greg Jensen's Blog</title><link href="/styles.css" rel="stylesheet" type="text/css" /></head><body><div class="center"><a href="/">Home</a><a href="/math.html">Math</a><a href="mailto:greg.micah.jensen@gmail.com">Email</a><a href="/blog">Blog</a><a href="https://www.github.com/g-jensen">GitHub</a></div><div class="post"><div><h1>Polymorphic Dispatch Revisited</h1><p>2023-07-03</p><!---
Tags:
[:clojure]
--><p>In a <a href="https://gregjensen.dev/blog/2023/06/13/polymorphic-dispatch.html">previous post about polymorphic dispatch</a>,
I outlined Clojure's <code>defprotocol</code> and <code>defrecord</code> as 'the' way to do polymorphic dispatch.</p><p>While <code>defprotocol</code> and <code>defrecord</code> are used for polymorphic dispatch, a much more common and simple
way to do it is with multimethods. I have a whole other post about multimethods <a href="https://gregjensen.dev/blog/2023/06/16/multimethods.html">here</a>.</p><p>In that post you can see that multimethods generally take less code and are nice because they work well
with maps. You can pass in a single object that maps to the dispatch value you want while also
carrying any other data needed for the calculation.
Using multimethods is also good because you aren't instantiating so many objects.</p><p>Overall, protocols and records/types are useful, but it's good to use maps and multimethods by default.</p></div></div></body>