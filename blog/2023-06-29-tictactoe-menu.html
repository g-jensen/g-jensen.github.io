<head><title>Greg Jensen's Blog</title><link href="/styles.css" rel="stylesheet" type="text/css" /></head><body><div class="center"><a href="https://gregjensen.dev">Home</a><a href="https://gregjensen.dev/math.html">Math</a><a href="mailto:greg.micah.jensen@gmail.com">Email</a><a href="https://gregjensen.dev/blog">Blog</a><a href="https://www.github.com/g-jensen">GitHub</a></div><div class="post"><div><h1>TicTacToe Menu</h1><p>2023-06-29</p><!---
Tags:
[:clojure]
--><p>In an attempt to make my TicTacToe menu system more testable and less fragile, I have all
the necessary behavior stored using multimethods and maps.</p><p>To save the state within the main menu, I create a multimethod named <code>next-state</code> which
takes in a <code>state</code> and an<code>input</code></p><p>So the first couple menu elements looks like this:</p><pre><code class="language-clojure">(defmulti next-state :state)

(defmethod next-state :default [state input]
  {:state :database})

(defmethod next-state :database [state input]
  (cond
    (= "1" input) (assoc state :database (FileDatabase. "games.txt") :state :load-type)
    (= "2" input) (assoc state :database (SQLDatabase. "games.db") :state :load-type)
     :else state))

(defmethod next-state :load-type [state input]
  (cond
    (= "1" input) (assoc state :load-type :new :state :board-size)
    (= "2" input) (assoc state :load-type :load :state :select-game)
    :else state))
</code></pre><p>This way we can keep calling <code>next-state</code> recursively and create an order. So something like</p><pre><code class="language-clojure">(loop [state (menu/next-state {} nil)]
      (if (= :done (:state state))
        state
        (recur (menu/next-state state (read-line)))))
</code></pre><p>Would keep prompting the console for new state information in the order we specified above.</p><p>To get the ui components of a menu, I use more multimethods:</p><pre><code class="language-clojure">(defmulti ui-components :state)

(defmethod ui-components :database [state]
  {:label "Database"
   :options ["1. File Database" "2. SQL Database"]})

(defmethod ui-components :load-type [state]
           {:label "Load Type"
            :options ["1. New Game" "2. Load Game"]})
</code></pre><p>This way, for a console game, I can just print the label and options while recurring through
the state like so:</p><pre><code class="language-clojure">(loop [state (menu/next-state {} nil)]
    (if (= :done (:state state))
      state
      (do (println (:label (menu/ui-components state)))
          (println (str/join "\n" (:options (menu/ui-components state))))
          (recur (menu/next-state state (read-line))))))
</code></pre></div></div></body>