<head><title>Greg Jensen's Blog</title><link href="/styles.css" rel="stylesheet" type="text/css" /></head><body><div class="center"><a href="https://gregjensen.dev">Home</a><a href="https://gregjensen.dev/math.html">Math</a><a href="mailto:greg.micah.jensen@gmail.com">Email</a><a href="https://gregjensen.dev/blog">Blog</a><a href="https://www.github.com/g-jensen">GitHub</a></div><div class="post"><div><h1>Modular Exponentiation</h1><p>2023-05-19</p><!---
Tags:
[:math :clojure]
--><p>Modular exponentiation refers to any expression in the form <code>b^e (mod n)</code>.</p><p>The simple way to calculate the value of this expression would be to simply calculate <code>b^e</code> and then
take that value <code>mod n</code>.</p><p>As <code>b</code> and <code>e</code> become large, calculating the value of this expression the simple way becomes very time-consuming and
can cause integer overflows even if the ending value is not large.</p><p>One way to greatly increase the speed and decrease the chance of integer overflows is to use Binary Exponentiation.
This process involves converting <code>e</code> into binary and then looping through the bits to take shortcuts.</p><p>The following implementation of Binary Exponentiation in Clojure (<code>mod-pow</code>) loops through of the bits of <code>e</code> from right to
left and is thus called Right-to-Left Binary Exponentiation:</p><pre><code class="language-clojure">(defn mod-pow-next [val exponent base n]
      (if (= 1 (mod exponent 2))
        (mod (* val base) n)
        val))

(defn mod-pow [base exponent n]
      (loop [base     base
             answer   1
             exponent exponent]
            (if (zero? exponent)
              answer
              (recur (mod (* base base) n)
                     (mod-pow-next answer exponent base n)
                     (quot exponent 2)))))
</code></pre><p>The <code>(quot exponent 2)</code> and <code>(if (= 1 (mod exponent 2))</code> are the parts that loop through of bits of <code>e</code></p><p>A small benchmark:</p><pre><code class="language-clojure">(time (mod-pow 93 163 4))
"Elapsed time: 0.084 msecs"
=> 1
(time (mod (pow 93 163) 4))
"Elapsed time: 1.441667 msecs"
=> 1N
</code></pre><p>Notice that the simple way returns <code>1N</code> as opposed to <code>1</code>. This shows that it
first calculated <code>93^163</code> and then just took that <code>(mod 4)</code>. But the more sophisticated method only returns
<code>1</code> because it never actually gets to numbers high enough to have to use <code>BigInteger</code></p></div></div></body>