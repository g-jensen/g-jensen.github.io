<head><title>Greg Jensen's Blog</title><link href="/styles.css" rel="stylesheet" type="text/css" /></head><body><div class="center"><a href="/">Home</a><a href="/math.html">Math</a><a href="mailto:greg.micah.jensen@gmail.com">Email</a><a href="/blog">Blog</a><a href="https://www.github.com/g-jensen">GitHub</a></div><div class="post"><div><h1>Traveling Salesman</h1><p>2023-06-05</p><!---
Tags:
[:clojure]
--><p>The Traveling Salesman problem, my latest kata, asks: <code>given a list of points, what is the shortest path to visit every point and return to the first point?</code></p><p>My solution was to simply check every permutation of the points and pick the path with the shortest length. This strategy is exceptionally slow. O(n!) slow, in fact. My main function in Clojure boiled down to the following:</p><pre><code class="language-clojure">(def shortest-path [points]
  (apply min-key #(path-length (conj % (first points))) (permutations points)))
</code></pre><p>When doing some research on the problem, I found an optimized algorithm that runs in O(n^2 * 2^n) and even a quantum algorithm that runs in O(1.728^n).</p><p>But one interesting approximation of the solution I found uses ant colonies. Real ants create paths by taking into account trail pheromones, and the algorithm uses a probabilistic approach by simulating how ant colonies choose paths between food sources. Essentially, a large amount of ants are sent out to explore many routes and each ant will choose the next node based on the distance and amount of virtual pheromone on the node. This simulation gives a decent and quick approximation for the Traveling Salesman problem.</p></div></div></body>