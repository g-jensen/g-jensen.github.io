<head><title>Greg Jensen's Blog</title><link href="/styles.css" rel="stylesheet" type="text/css" /></head><body><div class="center"><a href="https://gregjensen.dev">Home</a><a href="https://gregjensen.dev/math.html">Math</a><a href="mailto:greg.micah.jensen@gmail.com">Email</a><a href="https://gregjensen.dev/blog">Blog</a><a href="https://www.github.com/g-jensen">GitHub</a></div><div class="post"><div><h1>Project Euler #14</h1><p>2023-05-26</p><!---
Tags:
[:euler :clojure]
--><p>Euler #14 asks
<code>Which starting number, under one million, produces the longest Collatz sequence?</code></p><p>The naive and relatively fast approach looks at follows:</p><pre><code class="language-clojure">(defn next-collatz [n]
  (if (even? n)
    (quot n 2)
    (inc (* 3 n))))

(defn collatz-seq [n]
  (if (= n 1)
    [1]
    (cons n (lazy-seq (collatz-seq (next-collatz n))))))

(defn collatz-seq-count [n]
  (count (collatz-seq n)))

(defn euler-14 [n] 
  (apply max-key collatz-seq-count (range 1 n)))
</code></pre><p>It gets the job done and in reasonable time:</p><pre><code class="language-clojure">(time (euler-14 1000000))
"Elapsed time: 3591.471 msecs"
=> 837799
</code></pre><p>But a pretty obvious optimization is to remember previous lengths of Collatz sequences so that it isn't
necessary to recompute the whole sequence. I tried going the <code>memoize</code> route for this, but the fact that
you need to check if a value has already been cached complicated the procedure.</p><p>Here is my messy, but quicker approach:</p><pre><code class="language-clojure">(defn next-collatz [n]
  (if (even? n)
    (quot n 2)
    (inc (* 3 n))))

(defn collatz-seq [n]
  (if (= n 1)
    [1]
    (cons n (lazy-seq (collatz-seq (next-collatz n))))))

(defn collatz-seq-count [n map]
  (loop [m 1 val n]
    (cond
      (= val 1) m
      (contains? map val) (+ m (get map val))
      :else (recur (inc m) (next-collatz val)))))

(defn euler-14 [n]
  (loop [m 1 max-key 0 max-val 0 map {}]
    (if (>= m n)
      max-key
      (let [count (collatz-seq-count m map)]
          (recur (inc m) (if (> count max-val) m max-key) (max max-val count) (assoc map m count))))))
</code></pre><p>It shaves off about two seconds:</p><pre><code class="language-clojure">(time (euler-14 1000000))
"Elapsed time: 916.799042 msecs"
=> 837799
</code></pre></div></div></body>