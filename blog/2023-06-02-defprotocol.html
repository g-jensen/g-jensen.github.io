<head><title>Greg Jensen's Blog</title><link href="/styles.css" rel="stylesheet" type="text/css" /></head><body><div class="center"><a href="/">Home</a><a href="/math.html">Math</a><a href="/contact.html">Contact</a><a href="/blog">Blog</a><a href="https://www.github.com/g-jensen">GitHub</a></div><div class="post"><div><h1>Defprotocol</h1><p>2023-06-02</p><!---
Tags:
[:clojure]
--><p><code>defprotocol</code> is Clojure's strategy for allowing dynamic polymorphism.</p><p>When using <code>defprotocol</code>, implementations of functions are not included.</p><pre><code class="language-clojure">(defprotocol GameObject 
  (update-obj [this]))
</code></pre><p>Here, we create a protocol named <code>GameObject</code> and define a function <code>update-obj</code> but do not implement it.</p><p>Now we can create types that derive from <code>GameObject</code>:</p><pre><code class="language-clojure">(deftype Player [] 
  GameObject
  (update-obj [this] "update player stuff"))

(deftype LightSource []
  GameObject
  (update-obj [this] "update light source stuff"))
</code></pre><p>We can now call <code>update-obj</code> polymorphically on <code>Player</code> or <code>LightSource</code></p><pre><code class="language-clojure">(update-obj (Player.))      ;=> "update player stuff"
(update-obj (LightSource.)) ;=> "update light source stuff"
</code></pre></div></div></body>